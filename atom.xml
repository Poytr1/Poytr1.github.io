<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Freedom Is Slavery Ignorance Is Strength</title>
  <subtitle>I&#39;m Peterson Xu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-03-13T02:40:25.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Peterson Xu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里面经总结</title>
    <link href="http://yoursite.com/2017/03/12/%E9%98%BF%E9%87%8C%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/03/12/阿里面经总结/</id>
    <published>2017-03-12T11:34:28.000Z</published>
    <updated>2017-03-13T02:40:25.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="阿里电面题汇总（java研发）"><a href="#阿里电面题汇总（java研发）" class="headerlink" title="阿里电面题汇总（java研发）"></a>阿里电面题汇总（java研发）</h1><ol>
<li><strong>从下往上说一下OSI七个分层？</strong> </li>
</ol>
<ul>
<li>物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li>
</ul>
<ol>
<li><p><strong>TCP和UDP的区别</strong>？</p>
<ul>
<li>TCP提供面向连接的、可靠的数据流传输，而UDP提供的是非面向连接的、不可靠的数据流传输。（TCP发出去还会问候核实一下以确保安全; UDP发出去就不管了 ）</li>
<li>TCP传输单位称为TCP报文段，UDP传输单位称为用户数据报。</li>
<li>TCP注重数据安全性，UDP数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。</li>
</ul>
</li>
<li><p><strong>说说数据库连接（join）？</strong></p>
<ul>
<li>Inner join–产生的是AB两个集合的交集    </li>
<li>left[outer]join–产生A的完全集，而B中匹配的则有值，没有匹配的则返回null </li>
<li>right[outer]join–产生B的完全集，而A中匹配的则有值，没有匹配的则返回null </li>
</ul>
</li>
<li><p><strong>说说事务？</strong></p>
<ul>
<li>所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。</li>
</ul>
</li>
<li><p><strong>HashMap原理？</strong></p>
<ul>
<li><p>底层是数组加链表实现的哈希表。允许null作为键，null作为值。线程不安全。</p>
</li>
<li><p>为什么用数组+链表实现？</p>
<p>利用拉链法解决冲突：把所有的同义词用单链表链接起来。该方法下，哈希表每个单元中存放的不再是元素本身，而是相应同义词单链表的头指针。</p>
</li>
<li><p>HashMap维护了一个Entry数组，Entry内部类有key,value，hash和next四个字段，其中next也是一个Entry类型。可以将Entry数组理解为一个个的散列桶。每一个桶实际上是一个单链表。当执行put操作时，会根据key的hashcode定位到相应的桶。   遍历单链表检查该key是否已经存在，如果存在，覆盖该value，反之，新建一个新的Entry，并放在单链表的头部。当通过传递key调用get方法时，它再次使用key.hashCode()来找到相应的散列桶，然后使用key.equals()方法找出单链表中正确的Entry，然后返回它的值。 </p>
</li>
<li><p>HashMap：线程不同步。根据key的hashcode进行存储，内部使用静态内部类Node的数组进行存储，默认初始大小为16，每次扩大一倍。当发生Hash冲突时，采用拉链法（链表）。可以接受为null的键值(key)和值(value)。JDK1.8中：当单个桶中元素个数大于等于8时，链表实现改为红黑树实现；当元素个数小于6时，变回链表实现。由此来防止hashCode攻击。 </p>
</li>
<li><p>Hashtable是线程安全的。ConcurrentHashMap 针对读操作做了大量的优化。通过 HashEntry 对象的不变性和用 volatile 型变量协调线程间的内存可见性，使得 大多数时候，读操作不需要加锁就可以正确获得值。这个特性使得 ConcurrentHashMap 的并发性能在分离锁的基础上又有了近一步的提高。ConcurrentHashMap 的高并发性主要来自于三个方面：</p>
<ul>
<li>用分离锁实现多个线程间的更深层次的共享访问。</li>
<li>用 HashEntery 对象的不变性来降低执行读操作的线程在遍历链表期间对加锁的需求。</li>
<li>通过对同一个 Volatile 变量的写 / 读访问，协调不同线程间读 / 写操作的内存可见性。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Java运行时数据区域？</strong> </p>
<ul>
<li>包括程序计数器、JVM栈、本地方法栈、方法区、堆   </li>
</ul>
</li>
<li><p><strong>方法区里存放什么？</strong></p>
<ul>
<li>由于程序计数器、JVM栈、本地方法栈3个区域随线程而生随线程而灭，对这几个区域内存的回收和分配具有确定性。 而方法区和堆则不一样，程序需要在运行时才知道创建哪些对象，对这部分内存的分配是动态的，GC关注的也就是这部分内存。</li>
</ul>
</li>
</ol>
<ul>
<li>本地方法栈：和jvm栈所发挥的作用类似，区别是jvm栈为jvm执行java方法（字节码）服务，而本地方法栈为jvm使用的native方法服务。 </li>
<li>JVM栈：局部变量表、操作数栈、动态链接、方法出口。 </li>
<li>方法区：用于存储已被虚拟机加载的类信息，常量、静态变量、即时编译器编译后的代码等。 </li>
<li>堆：存放对象实例。</li>
</ul>
<ol>
<li><p><strong>怎样判断是否需要收集？</strong></p>
<ul>
<li>引用计数法：对象没有任何引用与之关联(无法解决循环引用) </li>
<li>可达性分析法：通过一组称为GC Root的对象为起点,从这些节点向下搜索，如果某对象不能从这些根对象的一个(至少一个)所到达,则判定该对象应当回收。 </li>
</ul>
</li>
<li><p><strong>什么可作为GCRoot的对象？</strong></p>
<ul>
<li>虚拟机栈中引用的对象。方法区中类静态属性引用的对象，方法区中类常量引用的对象，本地方法栈中JNI引用的对象。</li>
</ul>
</li>
<li><p><strong>Spring IOC/AOP？</strong>  </p>
</li>
</ol>
<ul>
<li><em>AOP（Aspect-OrientedProgramming，面向方面编程</em>,可以说是<em>OOP（Object-Oriented Programing，面向对象编程）</em>的补充和完善。 OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。 也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为<em>横切（cross-cutting）</em>代码， 在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。<em>依赖注入(Dependency Injection)</em>和<em>控制反转(Inversion of Control)</em>是同一个概念.当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例.但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入.不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。 在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:一个人(Java实例，调用者)需要一把斧子(Java实例，被调用者)。 </li>
</ul>
<ol>
<li><strong>自己在应用中写过什么切面？</strong></li>
</ol>
<p>AOP使用场景：  </p>
<ul>
<li>Authentication 权限 </li>
<li>Caching 缓存 <ul>
<li>Context passing 内容传递 </li>
<li>Error handling 错误处理 </li>
<li>Lazy loading　懒加载 </li>
<li>Debugging　　调试 </li>
<li>logging, tracing, profiling and monitoring　记录跟踪　优化　校准 </li>
<li>Performance optimization　性能优化 </li>
<li>Persistence　　持久化 </li>
<li>Resource pooling　资源池 </li>
<li>Synchronization　同步 </li>
<li>Transactions 事务</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>JVM如何加载一个类的过程，双亲委派模型中有哪些方法？</strong></p>
<ul>
<li><strong>加载</strong>：定位要加载的类文件，并将其字节流装载到JVM中；</li>
<li><strong>链接</strong>：给要加载的类分配最基本的内存结构保存其信息，比如属性，方法以及引用的类。在该阶段，该类还处于不可用状态；验证：对加载的字节流进行验证，比如格式上的，安全方面的；内存分配：为该类准备内存空间来表示其属性，方法以及引用的类；解析：加载该类所引用的其它类，比如父类，实现的接口等。</li>
<li><strong>初始化：</strong>对类变量进行赋值。</li>
<li><code>getParent()</code>,<code>findLoadedClass()</code>,<code>LoadClass()</code>,<code>findBootstrapClassOrNull()</code>,<code>findClass()</code>,<code>resolveClass()</code></li>
</ul>
</li>
<li><p><strong>进程间通信有哪几种方式？</strong></p>
<p>| 类型            | 无连接  | 可靠   | 流控制  | 优先级  |<br>| ————- | —- | —- | —- | —- |<br>| 消息队列          | N    | Y    | Y    | Y    |<br>| 信号量           | N    | Y    | Y    | Y    |<br>| 共享内存          | N    | Y    | Y    | Y    |<br>| UNIX流SOCKET   | N    | Y    | Y    | N    |<br>| UNIX数据包SOCKET | Y    | Y    | N    | N    |<br>| 普通PIPE        | N    | Y    | Y    | N    |<br>| 流PIPE         | N    | Y    | Y    | N    |<br>| 命名PIPE(FIFO)  | N    | Y    | Y    | N    |</p>
</li>
<li><p><strong>Linux下如何进行进程调度的？</strong></p>
<ul>
<li><p><strong>实时进程的调度</strong></p>
<p>不同调度策略的实时进程只有在相同优先级时才有可比性：</p>
<ul>
<li>对于FIFO的进程，意味着只有当前进程执行完毕才会轮到其他进程执行。由此可见相当霸道。</li>
<li>对于RR的进程。一旦时间片消耗完毕，则会将该进程置于队列的末尾，然后运行其他相同优先级的进程，如果没有其他相同优先级的进程，则该进程会继续执行。</li>
</ul>
</li>
<li><p><strong>非实时进程调度</strong></p>
<p>Linux对普通的进程，根据动态优先级进行调度。而动态优先级是由静态优先级（static_prio）调整而来（考虑了进程的属性）。Linux下，静态优先级是用户不可见的，隐藏在内核中。</p>
</li>
<li><p><strong>现代方法CFS</strong></p>
<p>不再单纯依靠进程优先级绝对值，而是参考其绝对值，综合考虑所有进程的时间，给出当前调度时间单位内其应有的权重，也就是，每个进程的权重X单位时间=应获cpu时间，但是这个应得的cpu时间不应太小（假设阈值为1ms），否则会因为切换得不偿失。但是，当进程足够多时候，肯定有很多不同权重的进程获得相同的时间——最低阈值1ms，所以，CFS只是近似完全公平。</p>
</li>
</ul>
</li>
<li><p><strong>什么是一致性哈希？</strong></p>
<ul>
<li>将 Item 均匀地分布（Even Distribution）到不同的 Bucket 中，也就是<strong>负载均衡（Load Balancing）</strong>。</li>
<li>一致性哈希的实现：<ul>
<li>对所有的 Buckets 和 Items 应用相同的哈希函数 H，按照哈希值的顺序把它们排列到一条线上，然后将距离 Bucket 最近的 Items 都放入该 Bucket 中。</li>
<li>另一种实现方式是把哈希值的最大值和最小值连接到一起，形成一个哈希环（Consistent Hashing Ring），按照顺时针方向将 Items 放入 Bucket 中。</li>
</ul>
</li>
</ul>
</li>
<li><p>​</p>
</li>
</ol>
<hr>
<p>// to be continue…</p>
<p>​</p>
<p>​</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;阿里电面题汇总（java研发）&quot;&gt;&lt;a href=&quot;#阿里电面题汇总（java研发）&quot; class=&quot;headerlink&quot; title=&quot;阿里电面题汇总（java研发）&quot;&gt;&lt;/a&gt;阿里电面题汇总（java研发）&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;从下往上
    
    </summary>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>hw2</title>
    <link href="http://yoursite.com/2017/03/12/hw2/"/>
    <id>http://yoursite.com/2017/03/12/hw2/</id>
    <published>2017-03-12T04:26:15.000Z</published>
    <updated>2017-03-12T04:28:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Homework-2"><a href="#Homework-2" class="headerlink" title="Homework 2"></a>Homework 2</h1><h4 id="Problem-1-Lambda-Calculus-Reduction"><a href="#Problem-1-Lambda-Calculus-Reduction" class="headerlink" title="Problem 1: Lambda Calculus Reduction"></a>Problem 1: <em>Lambda Calculus Reduction</em></h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Rename bound variables:</div><div class="line">=&gt; (λx.λy.λz.x y z)(λp.λq.p q r)</div><div class="line">=&gt; λy.λz.[(λp.λq.p q r) y z]</div><div class="line">=&gt; λy.λz.y z r</div></pre></td></tr></table></figure>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">if we do not rename bound variables at the beginning:</div><div class="line">=&gt; (λp.λq.λr.p q r)(λp.λq.p q r)</div><div class="line">=&gt; λq.λr.[(λp.λq.p q r) q r]</div><div class="line">=&gt; λq.λr.[(λq.q q r) r]</div><div class="line">=&gt; λq.λr.r r r</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="Problem-2-Translation-into-Lambda-Calculus"><a href="#Problem-2-Translation-into-Lambda-Calculus" class="headerlink" title="Problem 2: Translation into Lambda Calculus"></a>Problem 2: <em>Translation into Lambda Calculus</em></h4><ul>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">f: λg. g(g)</div><div class="line">f(f): (λg. g(g))(λg. g(g))</div><div class="line">   =&gt; (λg. g(g))(λg. g(g))   (substitution)</div><div class="line">   =&gt; ...(infinite)</div></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="Problem-3-Lazy-Evaluation-and-Parallelism"><a href="#Problem-3-Lazy-Evaluation-and-Parallelism" class="headerlink" title="Problem 3: Lazy Evaluation and Parallelism"></a>Problem 3: <em>Lazy Evaluation and Parallelism</em></h4><p>(a) </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">It is possible that the process g which is evaluating test (x=0) or (x+y=0) will have to wait for the process evaluating e1 or e2.When the e1 or e2 is not a fixed value which need to be computed,this phenomenon can be happen.</div></pre></td></tr></table></figure>
<p>(b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">The expression g(e1,e2) will not be terminated with lazy evaluation because the evaluation of e2 will never be reached.</div><div class="line">Expression g(e1,e2) may not be terminated with parallel evaluation under the circumstances that the &apos;g&apos; process and &apos;e1&apos; process both complete successfully before &apos;e2&apos; process terminates.Also,it may be terminated.</div></pre></td></tr></table></figure>
<p>(c)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">No matter what happens, keep evaluating g(e1,e2). (When e1/e2 terminates,g needn&apos;t stop.)</div></pre></td></tr></table></figure>
<p>(d)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I cannot evaluate the arguments of g(e1,e2) in parallel because that the evaluation of e2 has affected the results of e1, e1 e2 execution order is uncertain, results with different execution order are different.</div></pre></td></tr></table></figure>
<hr>
<h4 id="Problem-4-Modifying-functional-programs"><a href="#Problem-4-Modifying-functional-programs" class="headerlink" title="Problem 4: Modifying functional programs"></a>Problem 4: <em>Modifying functional programs</em></h4><p>(a)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Haskell program:</div><div class="line">Using the first element of a list as the pivot.</div><div class="line">C program:</div><div class="line">Using the last element of a list as the pivot.</div></pre></td></tr></table></figure>
<p>(b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Haskell program is easier to understand because it looks like a intuitive description about algorithm.I will choose first language to program.</div></pre></td></tr></table></figure>
<p>(c)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="title">qsort</span> []     = []</div><div class="line"><span class="title">qsort</span> (x:xs) = qsort (filter (&lt; x) xs) ++ [x] ++ qsort (filter (&gt;= x) xs)</div></pre></td></tr></table></figure>
<p>(d)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">qsort( a, lo, hi ) <span class="keyword">int</span> a[], hi, lo;</div><div class="line">&#123; </div><div class="line">  <span class="keyword">int</span> h, l, p, t, pivotIndex;  <span class="comment">//add a random index</span></div><div class="line">  <span class="keyword">if</span> (lo &lt; hi) &#123; </div><div class="line">    l = lo; </div><div class="line">    h = hi; </div><div class="line">    pivotIndex = l + rand()%(h - l + <span class="number">1</span>);   <span class="comment">//generate a random number between (l, h)</span></div><div class="line">    p = a[pivotIndex];</div><div class="line"></div><div class="line">    <span class="keyword">do</span> &#123; </div><div class="line">      <span class="keyword">while</span> ((l &lt; h) &amp;&amp; (a[l] &lt;= p))</div><div class="line">          l = l+<span class="number">1</span>; </div><div class="line">      <span class="keyword">while</span> ((h &gt; l) &amp;&amp; (a[h] &gt;= p))</div><div class="line">		  h = h<span class="number">-1</span>; </div><div class="line">      <span class="keyword">if</span> (l &lt; h) &#123; </div><div class="line">          t = a[l]; </div><div class="line">          a[l] = a[h]; </div><div class="line">          a[h] = t; </div><div class="line">      &#125; </div><div class="line">    &#125; <span class="keyword">while</span> (l &lt; h);</div><div class="line"></div><div class="line">    t = a[l]; </div><div class="line">    a[l] = a[hi]; </div><div class="line">    a[hi] = t;</div><div class="line"></div><div class="line">    qsort( a, lo, l<span class="number">-1</span> );</div><div class="line">    qsort( a, l+<span class="number">1</span>, hi );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(e)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Haskell program uses about n*log(n) extra space(every partition needs n space and we take this action for logn times).</div><div class="line">C quicksort whereby isorts the array in place; that is, without using any extra storage.But need extra stack sapce,so average: O(logn),worst_case:O(n).</div></pre></td></tr></table></figure>
<hr>
<h4 id="problem-5-Operational-Semantics"><a href="#problem-5-Operational-Semantics" class="headerlink" title="problem 5: Operational Semantics"></a>problem 5: <em>Operational Semantics</em></h4><p>(a)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">⟨x + y,σ⟩ → ⟨2 + y,σ⟩</div><div class="line">(rule 1:a1 → a′1/⟨a1 +a2, σ⟩ → ⟨a′1 +a2, σ⟩ &amp;&amp;</div><div class="line">rule 4: ⟨x, σ⟩ → ⟨σ(x), σ⟩)</div><div class="line">→ ⟨2 + 3,σ⟩  </div><div class="line">(rule 2:a2 → a′2/⟨n+a2, σ⟩ → ⟨n+a′2, σ⟩ &amp;&amp; rule 4)</div><div class="line">→ ⟨5,σ⟩ </div><div class="line">(rule 3: n, m, p are numbers with n + m = p/⟨n+m, σ⟩ → ⟨p, σ⟩)</div><div class="line">Answer:⟨x+y,σ⟩ → ⟨2 + y,σ⟩ → ⟨2 + 3,σ⟩ → ⟨5,σ⟩</div></pre></td></tr></table></figure>
<p>(b)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">⟨x = x +3,σ⟩ → ⟨x = 1 +3,σ⟩ (a1 → a′1/⟨a1 +a2, σ⟩ → ⟨a′1 +a2, σ⟩)</div><div class="line">→ ⟨x=4,σ⟩ (n, m, p are numbers with n + m = p/⟨n+m, σ⟩ → ⟨p, σ⟩)</div><div class="line">→ ⟨4,Put(σ,x,4)⟩ (⟨x = n,σ⟩ → ⟨n,Put(σ,x,n)⟩)</div><div class="line">Answer:⟨x = x +3,σ⟩ → ⟨x = 1 +3,σ⟩ → ⟨x=4,σ⟩ → ⟨4,Put(σ,x,4)⟩</div></pre></td></tr></table></figure>
<p>(c)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">⟨(x = 3) + x, σ⟩ → ⟨3 + x, put(σ,x,3)⟩</div><div class="line">→ ⟨3 + x, put(σ,x,3)⟩</div><div class="line">→ ⟨3 + 3, put(σ,x,3)⟩</div><div class="line">→ ⟨6, put(σ,x,3)⟩      (put(σ,x,3) &lt;=&gt; σ&apos;)</div></pre></td></tr></table></figure>
<p>(d)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">⟨x=(x=x+3)+(x=x+5), σ⟩   </div><div class="line">→ ⟨x=(x=1+3)+(x=x+5), σ⟩   σ(x) = 1 </div><div class="line">→ ⟨x=(x=4)+(x=x+5), σ⟩ </div><div class="line">→ ⟨x=4+(x=x+5), put(σ,x,4)⟩ </div><div class="line">→ ⟨x=4+(x=4+5), put(σ,x,4)⟩</div><div class="line">→ ⟨x=4+(x=9), put(σ,x,4)⟩</div><div class="line">→ ⟨x=4+9, put(σ,x,9)⟩</div><div class="line">→ ⟨x=13, put(σ,x,9)⟩</div><div class="line">→ ⟨13, put(σ,x,13)⟩</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Homework-2&quot;&gt;&lt;a href=&quot;#Homework-2&quot; class=&quot;headerlink&quot; title=&quot;Homework 2&quot;&gt;&lt;/a&gt;Homework 2&lt;/h1&gt;&lt;h4 id=&quot;Problem-1-Lambda-Calculus-Reducti
    
    </summary>
    
    
  </entry>
  
</feed>
